# 函数题
## 6-1 二分查找
```cpp
Position BinarySearch( List L, ElementType X )
{
    int l = 1, r = L->Last;
    while(l < r)
    {
        int mid =( l + r + 1 )>> 1;
        if(L->Data[mid] <= X)
            l = mid;
        else 
            r = mid - 1;
    }

    if(L->Data[l] == X)
        return l;
    else 
        return NotFound;
}
```
## 6-2 顺序表操作集
## 6-3 带头结点的链式表操作集
## 6-4 单链表逆转
## 6-5 两个有序链表序列的合并
## 6-6 在一个数组中实现两个堆栈
## 6-7 另类循环队列
## 6-8 双端队列
## 6-9 求二叉树高度
```cpp
int GetHeight( BinTree BT )
{
    int lh = 0, rh = 0;
    if(BT)
    {
        lh = GetHeight(BT->Left);
        rh = GetHeight(BT->Right);
        return lh > rh ? ++lh : ++rh;
    }
    return 0;
}
```
## 6-10 邻接矩阵存储图的深度优先遍历
```cpp
void DFS( MGraph Graph, Vertex V, void (*Visit)(Vertex) )
{
    Visit(V);
    Visited[V] = true;
    for(int i = 0; i < Graph->Nv; i++)
        if(Graph->G[V][i] == 1 && !(Visited[i]))
            DFS(Graph, i, Visit);
}


```
## 6-11 邻接表存储图的广度优先遍历
```cpp
void BFS ( LGraph Graph, Vertex S, void (*Visit)(Vertex) )
{
    Visit(S);
    Visited[S] = true;

    int head = 0, rear = 0;
    PtrToAdjVNode queue[MaxVertexNum];
    queue[rear++] = Graph->G[S].FirstEdge;
    while(head !=  rear)
    {
        PtrToAdjVNode p = queue[head++];
        while(p)
        {
            if(!Visited[p->AdjV])
            {
                Visit(p->AdjV);
                Visited[p->AdjV] = true;
                queue[rear++] = Graph->G[p->AdjV].FirstEdge;
            }    
            p = p->Next;
        }
    }
}
```
## 6-4（选做） 线性探测法的查找函数
```cpp
Position Find(HashTable H, ElementType Key)
{
    Position p = Hash(Key, H->TableSize);
    if (H->Cells[p].Data == Key || H->Cells[p].Info == Empty)
        return p;
    else
    {
        for (int i = 1; i < H->TableSize; i++)
        {
            Position m = (p + i) % H->TableSize;
            if (H->Cells[m].Data == Key || H->Cells[m].Info == Empty)
                return m;
        }
        return ERROR;
    }
}
```
## 6-13 Iterative Mergesort
## 6-14 Quick Power
```cpp
int Power(int a, int k)
{
    long long res = 1;
    while(k)
    {
        if(k & 1)
            res = res * a % MOD;
        a = 1ll * a * a % MOD;
        k >>= 1;
    }
    return res % MOD; 
}


```
## 6-15 划分整数数组
## 6-16 0/1背包问题 （队列式分枝限界法）
## 6-17 0/1背包问题 （优先队列分枝限界法）

# 编程题
## 7-1 栈操作的合法性
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n, m;
    std::cin >> n >> m;

    std::vector<std::string> s(n);
    for(int i = 0; i < n; i++)
        std::cin >> s[i];
    for(int i = 0, j; i < n; i++)
    {
        int cnt = 0;
        for(j = 0; j < s[i].size(); j++)
        {
            if(s[i][j] == 'S' && cnt < m)
                cnt++;
            else if(s[i][j] == 'X' && cnt > 0)
                cnt--;
            else    
                break;
        }
        if(j == s[i].size() && cnt == 0)
            std::cout << "YES\n";
        else 
            std::cout << "NO\n";
    }
    return 0;
}
```
## 7-2 银行业务队列简单模拟
## 7-3 PAT排名汇总
## 7-4 根据后序和中序遍历输出前序遍历
## 7-5 愿天下有情人都是失散多年的兄妹
## 7-6 家庭房产
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 10010;
struct DSU
{
	std::vector<int> f, siz;
	DSU(int n) : f(n), siz(n, 1)
	{
		std::iota(f.begin(), f.end(), 0);
	}
	int leader(int x)
	{
		return x == f[x] ? x : f[x] = leader(f[x]);
	}
	bool same(int x, int y)
	{
		return leader(x) == leader(y);
	}
	void merge(int x, int y)
	{
		x = leader(x), y = leader(y);
		int mx = std::max(x, y), mn = std::min(x, y); // 保证家庭编号最小
		if (x != y)
		{
			siz[mn] += siz[mx];
			f[mx] = mn;
		}
	}
	int size(int x)
	{
		return siz[leader(x)];
	}
};
struct Ans
{
	int id;		 // 家庭成员的最小编号
	int all_peo; // 家庭人口数
	int flag;
	double avg_cnt;	 // 人均房产套数
	double avg_area; // 人均房产面积
} res[N];
struct family
{
	int id, cnt, area;
} f[N];
bool cmp(Ans a1, Ans a2)
{
	if (a1.avg_area != a2.avg_area)
		return a1.avg_area > a2.avg_area;
	else
		return a1.id < a2.id;
} // 自定义排序
int main()
{
	// std::ios::sync_with_stdio(false);
	// std::cin.tie(nullptr);
	int n;
	std::cin >> n;
	DSU dsu(N);
	std::map<int, bool> vis;
	for (int i = 0; i < n; i++)
	{
		int id, fa, mo;
		std::cin >> id >> fa >> mo;
		vis[id] = true;
		if (~fa)
		{
			vis[fa] = true;
			dsu.merge(id, fa);
		}
		if (~mo)
		{
			vis[mo] = true;
			dsu.merge(id, mo);
		}
		int k;
		std::cin >> k;
		for (int i = 0, x; i < k; i++)
		{
			std::cin >> x;
			vis[x] = true;
			dsu.merge(id, x);
		}
		int cnt, area;
		std::cin >> cnt >> area;
		f[i] = {id, cnt, area};
	}
	int num = 0;
	for (int i = 0; i < N; i++)
	{
		int tmp = dsu.leader(f[i].id); // 祖先
		res[tmp].id = tmp;
		res[tmp].all_peo = 0;
		res[tmp].avg_cnt += f[i].cnt;	// 房产数量
		res[tmp].avg_area += f[i].area; // 面积
		res[tmp].flag = true;
	}
	for (int i = 0; i < N; i++)
		if (vis[i])
			res[dsu.leader(i)].all_peo++; // 计算每户人家人数
	for (int i = 0; i < N; i++)
	{
		if (res[i].flag && vis[i])
		{
			res[i].avg_cnt = res[i].avg_cnt / res[i].all_peo;	// 求平均数量
			res[i].avg_area = res[i].avg_area / res[i].all_peo; // 求平均面积
			num++;												// 计算家庭数量
		}
	}
	std::cout << num << '\n';
	std::sort(res, res + N, cmp);
	for (int i = 0; i < num; i++)
		printf("%04d %d %.3f %.3f\n", res[i].id, res[i].all_peo,
			   res[i].avg_cnt, res[i].avg_area);
	// 此处用printf优于std::cout
	return 0;
}
```
## 7-7 深入虎穴
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
    
	int n;
	std::cin >> n;
	int root = n * (n - 1) / 2;
	std::vector<int> adj[n];
	for (int i = 0; i < n; i++)
	{
		int k;
		std::cin >> k;
		if (k)
		{
			while (k--)
			{
				int x;
				std::cin >> x;
				x--;
				adj[i].push_back(x);
				root -= x;
			}
		}
	} // 建图
    
	auto bfs = [&](int root)
	{
		int u;
		std::queue<int> q;
		q.push(root);
		while (q.size())
		{
			u = q.front();
			q.pop();
			if (!adj[u].size())
				continue;
			for (auto v : adj[u])
				q.push(v);
		}
		return u + 1;
	}; // bfs遍历
    
	std::cout << bfs(root) << '\n';
	return 0;
}
```
## 7-4（选做）公路村村通
```cpp
#include <bits/stdc++.h>
using i64 = long long;
struct Edge
{
    int u, v, w;
    bool operator<(const Edge &t) const
    {
        return w < t.w;
    }
};
struct DSU
{
    std::vector<int> f, siz;
    DSU(int n) : f(n), siz(n, 1)
    {
        std::iota(f.begin(), f.end(), 0);
    }
    int leader(int x)
    {
        return x == f[x] ? x : f[x] = leader(f[x]);
    }
    bool same(int x, int y)
    {
        return leader(x) == leader(y);
    }
    void merge(int x, int y)
    {
        x = leader(x), y = leader(y);
        if (x != y)
        {
            siz[x] += siz[y];
            f[y] = x;
        }
    }
    int size(int x)
    {
        return siz[leader(x)];
    }
}; 
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n, m;
    std::cin >> n >> m;
    std::vector<Edge> edge(m);
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        std::cin >> u >> v >> w;
        u--, v--;
        edge[i] = {u, v, w};
    }
    std::sort(edge.begin(), edge.end()); // 预处理结束
    
    DSU dsu(n);
    
    auto kruskal = [&]()
    {
        int res = 0, cnt = 0;
        for (int i = 0; i < m; i++)
        {
            int a = edge[i].u, b = edge[i].v, c = edge[i].w;
            if (!dsu.same(a, b))
            {
                res += c, cnt++;
                dsu.merge(a, b);
            }
        }
        if (cnt < n - 1)
            return -1;
        else
            return res;
    };
    
    std::cout << kruskal() << '\n';
    return 0;
}
```
## 7-6（选做）关键活动
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int inf = 0x3f3f3f3f;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n, m, res = 0;
    std::cin >> n >> m;
    std::vector<int> st(n), ed(n, inf);           // 记录每个事件的最早发生时间和最晚发生时间
    std::vector<int> indeg(n), outdeg(n);         // 分别记录每个点的入度与出度
    std::vector adj(n, std::vector<int>(n, inf)); // 记录两边之间的权值
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        std::cin >> u >> v >> w;
        u--, v--;
        adj[u][v] = w;
        outdeg[u]++, indeg[v]++;
    } // 建图
    
    auto topsort = [&]() // 第一次拓扑排序
    {
        std::queue<int> q;
        for (int i = 0; i < n; i++)
            if (!indeg[i])
                q.push(i);
        int cnt = 0;
        while (q.size())
        {
            int u = q.front();
            q.pop();
            cnt++;
            for (int i = 0; i < n; i++)
            {
                if (adj[u][i] != inf) // u,i相连
                {
                    indeg[i]--;
                    if (!indeg[i])
                        q.push(i);
                    st[i] = std::max(st[i], st[u] + adj[u][i]);
                    res = std::max(res, st[i]);
                }
            }
        }
        return cnt != n; // 遍历点的个数与点的总个数不相等 说明无法完成
    };
    
    auto topsort2 = [&]() -> void // 第二次拓扑排序
    {
        std::queue<int> q;
        for (int i = 0; i < n; i++)
            if (!outdeg[i])
                q.push(i), ed[i] = res; // 如果出度为0，说明是终点，最晚完成时间就等于整个工程的所需时间
        while (q.size())
        {
            int u = q.front();
            q.pop();
            for (int i = n - 1; i >= 0; i--)
            {
                if (adj[i][u] != inf)
                {
                    outdeg[i]--;
                    if (!outdeg[i])
                        q.push(i);
                    ed[i] = std::min(ed[i], ed[u] - adj[i][u]);
                }
            }
        }
    };
    
    if (!topsort())
    {
        std::cout << res << '\n';
        topsort2();
        for (int i = 0; i < n; i++)
            for (int j = n - 1; j >= 0; j--)
                if (adj[i][j] != inf && st[i] + adj[i][j] == ed[j])
                    std::cout << i + 1 << "->" << j + 1 << '\n';
    }
    else
        std::cout << "0\n";
    return 0;
}
```
## 7-7（选做）旅游规划
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int inf = 0x3f3f3f3f;
struct Node
{
    int distant, cost;
};
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n, m, s, d;
    std::cin >> n >> m >> s >> d;
    std::vector<std::pair<int, Node>> adj[n];
    while (m--)
    {
        int u, v, len, fee;
        std::cin >> u >> v >> len >> fee;
        Node node = {len, fee};
        adj[u].push_back({v, node});
        adj[v].push_back({u, node});
    } // 建图
    std::vector<bool> vis(n);
    std::vector<int> dis(n, inf), cos(n, inf);
    
    auto dijkstra = [&]() -> void
    {
        dis[s] = 0, cos[s] = 0;
        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> q;
        q.push({0, s});
        while (q.size())
        {
            int u = q.top().second;
            q.pop();
            if (vis[u])
                continue;
            vis[u] = true;
            for (auto [v, tnode] : adj[u])
            {
                if (dis[v] > dis[u] + tnode.distant)
                {
                    dis[v] = dis[u] + tnode.distant;
                    cos[v] = cos[u] + tnode.cost;
                    q.push({dis[v], v});
                }
                else if (dis[v] == dis[u] + tnode.distant)
                {
                    cos[v] = std::min(cos[v], cos[u] + tnode.cost);
                    q.push({dis[v], v});
                }
            }
        }
    }; // dijkstra堆优化
    
    dijkstra();
    std::cout << dis[d] << ' ' << cos[d] << '\n';
    return 0;
}

```
## 7-11 奥运排行榜
```cpp
#include <bits/stdc++.h>
using i64 = long long;
struct node
{
    int id, gold, medal, people;
    double ave_gold, ave_medle;
    int rank, tmp, way;
};
bool cmp(node a, node b)
{
    return a.gold > b.gold;
} // 自定义排序函数
bool cmp2(node a, node b)
{
    return a.medal > b.medal;
}
bool cmp3(node a, node b)
{
    return a.ave_gold > b.ave_gold;
}
bool cmp4(node a, node b)
{
    return a.ave_medle > b.ave_medle;
}
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n, q;
    std::cin >> n >> q;
    std::vector<node> nation(n);
    for (int i = 0; i < n; i++)
    {
        int gold, medal, people;
        std::cin >> gold >> medal >> people;
        double ave_gold = gold * 1.0 / people;
        double ave_medal = medal * 1.0 / people;
        nation[i] = {i, gold, medal, people, ave_gold, ave_medal};
    } // 读入，处理奖牌数
    std::sort(nation.begin(), nation.end(), cmp);
    for (int i = 0; i < n; i++)
    {
        nation[i].way = 1;
        if (i >= 1 && nation[i].gold == nation[i - 1].gold)
            nation[i].rank = nation[i - 1].rank; // 存在并列关系，排名与前一位相同
        else
            nation[i].rank = i + 1; // 无并列关系，排名为i+1
    }                               // 按金牌排序
    std::sort(nation.begin(), nation.end(), cmp2);
    for (int i = 0; i < n; i++)
    {
        if (i >= 1 && nation[i].medal == nation[i - 1].medal)

            nation[i].tmp = nation[i - 1].tmp;
        else
            nation[i].tmp = i + 1; // 此处用tmp存储，之后根据关系更新rank
        if (nation[i].rank > nation[i].tmp)
        {
            nation[i].way = 2;
            nation[i].rank = nation[i].tmp;
        }
    } // 按奖牌排序
    std::sort(nation.begin(), nation.end(), cmp3);
    for (int i = 0; i < n; i++)
    {
        if (i >= 1 && nation[i].ave_gold == nation[i - 1].ave_gold)
            nation[i].tmp = nation[i - 1].tmp;
        else
            nation[i].tmp = i + 1;
        if (nation[i].rank > nation[i].tmp)
        {
            nation[i].way = 3;
            nation[i].rank = nation[i].tmp;
        }
    } // 按人均金牌排序
    std::sort(nation.begin(), nation.end(), cmp4);
    for (int i = 0; i < n; i++)
    {
        if (i >= 1 && nation[i].ave_medle == nation[i - 1].ave_medle)
            nation[i].tmp = nation[i - 1].tmp;
        else
            nation[i].tmp = i + 1;
        if (nation[i].rank > nation[i].tmp)
        {
            nation[i].way = 4;
            nation[i].rank = nation[i].tmp;
        }
    } // 按人均奖牌排序
    std::vector<std::pair<int, int>> rank(n);
    for (int i = 0; i < n; i++)
        rank[nation[i].id] = {nation[i].rank, nation[i].way}; // 建立数组的映射关系
    for (int i = 0, nation; i < q - 1; i++)
    {
        std::cin >> nation;
        std::cout << rank[nation].first << ':' << rank[nation].second << ' ';
    } // 查表输出
    int x;
    std::cin >> x;
    std::cout << rank[x].first << ':' << rank[x].second; // 注意末尾空格
    return 0;
}

```
## 7-3（选做）航空公司VIP客户查询
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
    int n, m;
    std::cin >> n >> m;
    std::map<std::string, i64> mp;
    for (int i = 0, dis; i < n; i++)
    {
        std::string t;
        std::cin >> t >> dis;
        mp[t] += (dis <= m ? m : dis);
    }
    
    int q;
    std::cin >> q;
    while (q--)
    {
        std::string t;
        std::cin >> t;
        if (!mp[t])
            std::cout << "No Info\n";
        else
            std::cout << mp[t] << '\n';
    }
    return 0;
}
```
## L2-012 关于堆的判断
## 7-5 冒泡法排序
```cpp
#include <bits/stdc++.h>
constexpr int N = 110;
int a[N];
int main()
{
    int n, k;
    std::cin >> n >> k;

    for(int i = 0; i < n; i++)
        std::cin >> a[i];

    for(int i = 0; i < k; i++)
        for(int j = 0; j < n - 1; j++)
            if(a[j] > a[j + 1])
                std::swap(a[j], a[j + 1]);

    std::cout << a[0];
    for(int i = 1; i < n; i++)
        std::cout << ' ' << a[i];
    return 0;
}
```
## 7-3 城市间紧急救援
```cpp
#include <bits/stdc++.h>
constexpr int inf = 0x3f3f3f3f;
int main()
{
    int n, m, s, d;
    std::cin >> n >> m >> s >> d;

    std::vector<int> num(n);
    for (int i = 0; i < n; i++)
        std::cin >> num[i];

    std::vector<std::pair<int, int>> adj[n];
    for (int i = 0; i < m; i++)
    {
        int u, v, w;
        std::cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w});
    }

    std::vector<int> dis(n, inf);
    dis[s] = 0;
    std::vector<bool> vis(n);
    std::vector<int> path(n, -1);
    std::vector<int> pathnum(n);
    pathnum[s] = 1;
    std::vector<int> pernum(n);
    pernum[s] = num[s];

    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> q;
    q.push({0, s});
    while (q.size())
    {
        auto [dist, u] = q.top();
        q.pop();

        if (vis[u])
            continue;
        vis[u] = true;

        for (auto [v, w] : adj[u])
        {
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                pathnum[v] = pathnum[u];
                pernum[v] = pernum[u] + num[v];
                path[v] = u;
                q.push({dis[v], v});
            }
            else if (dis[v] == dis[u] + w)
            {
                pathnum[v] += pathnum[u];
                if (pernum[v] < pernum[u] + num[v])
                {
                    pernum[v] = pernum[u] + num[v];
                    path[v] = u;
                    q.push({dis[v], v});
                }
            }
        }
    }

    std::cout << pathnum[d] << ' ' << pernum[d] << '\n';
    std::function<void(int)> print = [&](int x)
    {
        if (x >= 0)
        {
            print(path[x]);
            if (x == s)
                std::cout << x;
            else
                std::cout << ' ' << x;
        }
    };
    print(d);
    return 0;
}
```
## 7-7 哈利·波特的考试
```cpp
#include <bits/stdc++.h>
constexpr int inf = 0x3f3f3f3f;
int main()
{
    int n, m;
    std::cin >> n >> m;

    std::vector<std::vector<int>> g(n, std::vector<int>(n, inf));
    while(m--)
    {
        int u, v, w;
        std::cin >> u >> v >> w;
        u--, v--;
        g[u][v] = g[v][u] = std::min(g[u][v], w);
    }

    for(int k = 0; k < n; k++)
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                g[i][j] = std::min(g[i][j], g[i][k] + g[k][j]);

    int  res = inf, animal = 0;
    for(int i = 0; i < n; i++)
    {
        int max = 0;
        for(int j = 0; j < n; j++)
        {
            if(g[i][j] > max && i != j)
                max = g[i][j];
        }
        if(max == inf)
        {
            std::cout << 0 << '\n';
            return 0;
        }
        if(res > max)
        {        
            res = std::min(res, max);
            animal = i + 1;
        }
    }
    std::cout << animal << ' ' << res << '\n';
    return 0;
}
```
## 7-17 修理牧场
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::priority_queue<int, std::vector<int>, std::greater<int>> q;
    for(int i = 0, x; i < n; i++)
        std::cin >> x, q.push(x);

    int res = 0;
    while(q.size() > 1)
    {
        int t = q.top();
        q.pop();
        
        t += q.top();
        q.pop();
        
        q.push(t);
        res += t;
    }
    std::cout << res;
    return 0;
}
```
## 7-4 哈夫曼编码
## 7-8 装箱问题
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n), b(n), c(n);
    for (int i = 0; i < n; i++)
        std::cin >> a[i];

    int k = 0;
    for (int i = 0; i < n; i++)
    {
        bool flag = false;
        for (int j = 0; j <= k; j++)
        {
            if ((a[i] + b[j]) <= 100)
            {
                b[j] += a[i];
                c[i] = j;
                flag = true;
                break;
            }
        }

        if (!flag)
        {
            k++;
            b[k] += a[i];
            c[i] = k;
        }
    }

    for (int i = 0; i < n; i++)
        std::cout << a[i] << ' ' << c[i] + 1 << '\n';
    std::cout << k + 1 << '\n';
    return 0;
}
```
## 7-9 选做 To Fill or Not to Fill
## 7-10 月饼
```cpp
#include<bits/stdc++.h>
using i64 = long long;
struct moon
{
    double num;
    double sum;
    double price;
    bool operator<(const moon& t) const
    { 
        return price > t.price; 
    }
};
int main()
{
    int n, d;
    std::cin >> n >> d;

    std::vector<moon> a(n);
    for(int i = 0; i < n; i++)
        std::cin >> a[i].num;
    for(int i = 0; i < n; i++)
    {   
        std::cin >> a[i].sum;
        a[i].price = a[i].sum / a[i].num; 
    }
    std::sort(a.begin(), a.end());

    double res = 0;
    for(int i = 0; i < n; i++)
    {
        if(a[i].num < d)
        {
            d -= a[i].num;
            res += a[i].sum;
        }  
        else 
        {
            res += d * a[i].price;
            break;
        }
    }
    std::cout << std::fixed << std::setprecision(2) << res << '\n';
    return 0;
}
```
## 7-11 会场安排问题
```cpp
#include <bits/stdc++.h>
struct node
{
    int st, ed;
    bool operator<(const node& t) const { return st < t.st; }
};

int main()
{
    int k;
    std::cin >> k;

    std::vector<node> events(k);
    for(int i = 0; i < k; i++)
       std::cin >> events[i].st >> events[i].ed;
    std::sort(events.begin(), events.end());

    // for(auto [x, y] : events)
    //     std::cout << x << ' ' << y << '\n';

    std::vector<int> room(k + 1);
    for(int i = 0; i < k; i++)
    {
        for(int j = 0; j < k; j++)
            if(room[j] <= events[i].st)
            {    
                room[j] = events[i].ed;
                break;
            }
    }

    int res = 0;
    for(int i = 0; i < k; i++)
        if(room[i])
            res++;
        else 
            break;
    std::cout << res << '\n';
        
    return 0;
}
```
## 7-12 活动选择问题
```cpp
#include<bits/stdc++.h>
using i64 = long long;
struct node
{
    int st, ed;
    bool operator<(const node& t) const { return ed < t.ed; }
};;
int main()
{
    int n;
    std::cin >> n;

    std::vector<node> events(n);
    for(int i = 0; i < n; i++)
        std::cin >> events[i].st >> events[i].ed;
    std::sort(events.begin(), events.end());

    int cnt = 0, ed = 0;
    for(int i = 0; i < n; i++)
        if(events[i].st >= ed)
            cnt++, ed = events[i].ed;
    std::cout << cnt << '\n';
    return 0;
}
```
## 7-13 （选做）森森快递
## 7-25 贪心法-找零钱
```cpp
#include<stdio.h>
int main(){
	int money;
	scanf("%d",&money);
	printf("fen5:%d, fen2:%d, fen1:%d, total:%d",money/5,money%5/2,money%5%2,money/5+money%5/2+money%5%2);
	return 0;
}
```
## 7-26 二分+贪心算法
## 7-27 古老的汉诺塔
```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    int res = 0;
    std::function<void(int, char, char, char)> hanio = [&](int n, char a, char b, char c)
    {
        res++;
        if (n == 1)
            std::cout << a << "-->" << c << '\n';
        else
        {
            hanio(n - 1, a, c, b);
            std::cout << a << "-->" << c << '\n';
            hanio(n - 1, b, a, c);
        }
    };

    hanio(n, 'A', 'B', 'C');
    std::cout << res << '\n';

    return 0;
}
```
## 7-28 士兵排队
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n), b(n);
    for(int i = 0; i < n; i++)
        std::cin >> a[i] >> b[i];
    std::sort(b.begin(), b.end());
    std::sort(a.begin(), a.end());
    for(int i = 0; i < n; i++)
        a[i] -= i;
    std::sort(a.begin(), a.end());

    int id = n / 2, res = 0;
    for(int i = 0; i < n; i++)
        res += std::abs(a[i] - a[id]) + std::abs(b[i] - b[id]);
    std::cout << res << '\n';
    return 0;
}
```
## 7-29 输油管道问题
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin >> n;
    std::vector<int> y(n);
    for(int i = 0, c; i < n; i++)
        std::cin >> c >> y[i];
    std::sort(y.begin(), y.end());
    i64 res = 0;
    for(int i = 0; i < n; i++)
        res += std::abs(y[i] - y[n / 2]);
    std::cout << res << '\n';
    return 0;
}
```
## 7-5 (选做）子序列的平均值
```cpp
#include <bits/stdc++.h>
int main()
{
    int n, m;
    std::cin >> n >> m;

    std::vector<double> a(n + 1);
    for (int i = 1; i <= n; i++)
        std::cin >> a[i];

    auto check = [&](double mid)
    {
        std::vector<double> s(n + 1);
        for (int i = 1; i <= n; i++)
            s[i] = s[i - 1] + a[i] - mid;

        double ans = -1e9, val = 1e9;
        for (int i = m; i <= n; i++)
        {
            val = std::min(val, s[i - m]);
            ans = std::max(ans, s[i] - val);
        }
        return ans >= 0;
    };

    double l = -1e6, r = 1e6;
    while (r - l > 1e-5)
    {
        double mid = (l + r) / 2;
        if (check(mid))
            l = mid;
        else
            r = mid;
    }
    std::cout << int(r * 1000) << '\n';
    return 0;
}
```
## 7-6 第k小元素
```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    std::cin >> n >> k;

    std::vector<int> a(n);
    for (int i = 0; i < n; i++)
        std::cin >> a[i];
    std::sort(a.begin(), a.end());
    std::cout << a[k - 1] << '\n';

    return 0;
}
```
## 7-32 铺设油井管道
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin >> n;
    std::vector<int> y(n);
    for(int i = 0, c; i < n; i++)
        std::cin >> c >> y[i];
    std::sort(y.begin(), y.end());
    i64 res = 0;
    for(int i = 0; i < n; i++)
        res += std::abs(y[i] - y[n / 2]);
    std::cout << res << '\n';
    return 0;
}
```
## 7-8 第k小
```cpp
#include<bits/stdc++.h>

using i64 = long long;

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n, k;
    std::cin >> n >> k;

    std::priority_queue<int, std::vector<int>, std::greater<int>> q;
    for(int i = 0, x; i < n; i++)
        std::cin >> x, q.push(x);

    k--;
    while(k--)
        q.pop();
    std::cout << q.top() << '\n';
    return 0;
}
```
## 7-34 幂次取余
```cpp
#include<bits/stdc++.h>
using i64 = long long;
i64 qmi(i64 a, i64 b, i64 c)
{
    i64 res = 1;
    while(b)
    {
        if(b & 1)
            res = res * a % c;
        a = a * a % c;
        b >>= 1;
    }
    return res;
}
int main()
{
    int t;
    std::cin >> t;
    while(t--)
    {
        int a, b, c;
        std::cin >> a >> b >> c;
        std::cout << qmi(a, b, c) << '\n';
    }
    return 0;
}
```
## 7-35 全排列（分治）
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> p(n);
    std::iota(p.begin(), p.end(), 1);

    std::function<void(int)> per = [&] (int u)
    {
        if(u == n - 1)
        {
            for(int i = 0; i < n; i++)
                std::cout << p[i] << " ";
            std::cout << '\n';
        }
        for(int i = u; i < n; i++)
        {
            std::swap(p[u], p[i]);
            per(u + 1);
            std::swap(p[u], p[i]);
        }
    };
    per(0);
    
    return 0;
}
```
## 7-36 抢红包
```cpp
#include <bits/stdc++.h>
struct node
{
    int id = 0;
    int cnt = 0;
    int mon = 0;
    bool operator<(const node &t) const
    {
        if (mon != t.mon)
            return mon > t.mon;
        else
        {
            if (cnt != t.cnt)
                return cnt > t.cnt;
            else
                return id < t.id;
        }
    }
};
int main()
{
    int n;
    std::cin >> n;

    std::vector<node> person(n);
    for (int i = 0, k; i < n; i++)
    {
        person[i].id = i;
        std::cin >> k;
        for (int j = 0; j < k; j++)
        {
            int x, y;
            std::cin >> x >> y;
            x--;
            person[i].mon -= y;
            person[x].cnt++;
            person[x].mon += y;
        }
    }
    // for (auto [x, y, z] : person)
    //     std::cout << x << ' ' << y << ' ' << z << '\n';

    std::sort(person.begin(), person.end());

    // for (auto [x, y, z] : person)
    //     std::cout << x << ' ' << y << ' ' << z << '\n';

    for (int i = 0; i < n; i++)
        std::cout << person[i].id + 1 << ' ' << std::fixed << std::setprecision(2) << person[i].mon * 1.0 / 100 << '\n';

    return 0;
}
```
## 7-37 最大公约数和最小公倍数
```cpp
#include <bits/stdc++.h>
int main()
{
    int n, m;
    std::cin >> n >> m;
    std::cout << std::__gcd(n, m) << ' ' << n * m / std::__gcd(n, m) << '\n';
}
```
## 7-38 求n以内最大的k个素数以及它们的和
```cpp
#include <bits/stdc++.h>
int main()
{
    int n, k;
    std::cin >> n >> k;
    
    auto is_prime = [&](int x)
    {
        if(x <= 1)
            return false;
        if(x == 2)
            return true;
        for(int i = 2; i <= x/ i; i++)
        {
            if(x % i == 0)
                return false;
        }
        return true;
    };

    int sum = 0;
    std::vector<int> res;
    for(int i = n; i >= 0; i--)
    {
        if(is_prime(i))
            res.push_back(i), sum += i;
        if(res.size() == k)
            break;
    }
    std::cout << res[0];
    for(int i = 1; i < res.size(); i++)
        std::cout << '+' << res[i];
    std::cout << '=' << sum;
}
```
## 7-39 判断素数
```cpp
#include <bits/stdc++.h>

using i64 = long long;

void solve()
{
    int n;
    std::cin >> n;

    auto is_prime = [&](int x)
    {
        if (x <= 1)
            return false;
        if (x == 2)
            return true;
        for (int i = 2; i <= x / i; i++)
        {
            if (x % i == 0)
                return false;
        }
        return true;
    };

    std::cout << (is_prime(n) ? "Yes\n" : "No\n");
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int t;
    std::cin >> t;

    while (t--)
    {
        solve();
    }

    return 0;
}
```
## 7-40 C程序设计 实验4-3 欧几里得算法求最大公约数
```cpp
#include <bits/stdc++.h>
int Gcd(int a, int b)
{
    if(a <= 0 || b <= 0)
        return -1;
    return std::__gcd(a, b);
    
}
int main()
{
    int a, b, c;
    scanf("%d %d", &a, &b);
    c = Gcd(a,b);
    if (c != -1)
    {
        printf("%d\n", c);
    }
    else
    {
        printf("Input number should be positive!\n");
    }
    return 0;
}

```
## 7-41 水仙花数
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    std::vector<int> a(10);
    for (int i = 0; i < 10; i++)
        a[i] = std::pow(i, n);

    int st = std::pow(10, n - 1), ed = std::pow(10, n);

    for (int i = st; i < ed; i++)
    {
        int s = 0, t = i;
        while (t)
            s += a[t % 10], t /= 10;
        if (s == i)
            std::cout << i << '\n';
    }
    return 0;
}
```
## 7-42 判断一个三位数是否为水仙花数
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;
    int k = 0, t = n, s = 0;
    while (t)
    {
        t /= 10;
        k++;
    }
    if (k != 3)
    {
        std::cout << "Invalid Value.\n";
        return 0;
    }

    t = n;
    while (t)
    {
        s += std::pow(t % 10, 3);
        t /= 10;
    }
    std::cout << (s == n ? "Yes\n" : "No\n");
    return 0;
}
```
## 7-43 租用游艇问题
```cpp
#include <bits/stdc++.h>
constexpr int inf = 0x3f3f3f3f;
int main()
{
    int n;
    std::cin >> n;

    std::vector rent(n, std::vector<int>(n));
    for(int i = 0; i < n - 1; i++)
        for(int j = i + 1; j < n; j++)
            std::cin >> rent[i][j];
    
    std::vector<int> f(n, inf);
    f[0] = 0;
    for(int i = 0; i < n; i++)
        for(int j = i + 1; j < n; j++)
            f[j] = std::min(f[j], f[i] + rent[i][j]);
    std::cout << f[n - 1] << '\n';
    return 0;
}
```
## 7-44 矩阵链相乘问题
```cpp
#include<bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n + 2);
    std::vector f(n+1, std::vector<int>(n+1, 0x3f3f3f3f));
    for(int i = 0; i <= n; i++)
        std::cin >> a[i], f[i][i] = 0;

    for(int len = 2; len <= n; len++)
    {
        for(int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            for(int k = i; k < j; k++)
                f[i][j] = std::min(f[i][j], f[i][k] + f[k + 1][j] + a[i - 1] * a[k] * a[j]);
        }
    }
    std::cout << f[1][n] << '\n';
    
    return 0;
}
```
## 7-45 字母表
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    int t;
    std::cin >> t;
    while(t--)
    {
        std::string s;
        std::cin >> s;
        int n = s.size();
        std::vector<int> a(n);
        for(int i = 0; i < s.size(); i++)
            a[i] = s[i] - 'a';

        std::vector<int> dp(n, 1);
        for(int i = 0; i < n; i++)
            for(int j = 0; j < i; j++)
                if(a[i] > a[j])
                    dp[i] = std::max(dp[i], dp[j] + 1);

        int res = 0;
        for(int i = 0; i < n; i++)
            res = std::max(res, dp[i]);
        std::cout << 26 - res << '\n';
    }
    return 0;
}
```
## 7-46 小H分糖果
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n);
    for(int i = 0; i < n; i++)
        std::cin >> a[i];

    std::vector<int> dp(n);
    for(int i = 0; i < n - 1; i++)
        if(a[i] < a[i + 1])
            dp[i + 1] = dp[i] + 1;

    for(int i = n - 1; i >= 1; i--)
        if(a[i - 1] > a[i])
            dp[i - 1] = std::max(dp[i - 1], dp[i] + 1);

    long long res = 0;
    for(int i = 0; i < n; i++)
        res += dp[i];
    std::cout << res + n << '\n';
    
    return 0;
}
```
## 7-47 运动会
```cpp
#include <bits/stdc++.h>

using i64 = long long;

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    std::vector<int> w(n);
    for (int i = 0; i < n; i++)
        std::cin >> w[i];

    std::vector<int> adj[n], leader(n, -1);
    for (int i = 0; i < n - 1; i++)
    {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[v].push_back(u);
        leader[u] = v;
    }

    int root = 0;
    while (leader[root] != -1)
        root++;

    std::vector<std::array<int, 2>> f(n);
    std::function<void(int)> dfs = [&](int u)
    {
        f[u][1] = w[u];
        for (auto v : adj[u])
        {
            dfs(v);
            f[u][1] += f[v][0];
            f[u][0] += std::max(f[v][0], f[v][1]);
        }
    };

    dfs(root);
    std::cout << std::max(f[root][0], f[root][1]) << '\n';

    return 0;
}
```
## 7-48 0-1背包
```cpp
#include <bits/stdc++.h>
int main()
{
    int n, m;
    std::cin >> n >> m;

    std::vector<int> v(n), w(n);
    for(int i = 0; i < n; i++)
        std::cin >> v[i] >> w[i];

    std::vector<int> f(m + 1);
    for(int i = 0; i < n; i++)
        for(int j = m; j >= v[i]; j--)
            f[j] = std::max(f[j], f[j - v[i]] + w[i]);

    std::cout << f[m] << '\n';
    return 0;
}
```
## 7-7 最长公共子序列长度
```cpp
#include <bits/stdc++.h>
int main()
{
    std::string a, b;
    std::cin >> a >> b; 
    a = " " + a, b = " " + b;

    int n = a.size(), m = b.size();
    std::vector dp(n + 1, std::vector<int>(m + 1));
    for(int i = 1; i < a.size(); i++)
    {
        for(int j = 1; j < b.size(); j++)
        {
            dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);
            if(a[i] == b[j])
                dp[i][j] = std::max(dp[i][j], dp[i - 1][j - 1] + 1);
        }
    }
    std::cout << dp[a.size() - 1][b.size() - 1] << '\n';
    return 0;
}
```
## 7-50 单调递增最长子序列
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n);
    for(int i = 0; i < n; i++)
        std::cin >> a[i];

    std::vector<int> dp(n, 1);
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < i; j++)
        {
            if(a[j] < a[i])
                dp[i] = std::max(dp[i], dp[j] + 1);
        }
    }

    int res = 0;
    for(int i = 0; i < n; i++)
        res = std::max(res, dp[i]);
    std::cout << res << '\n';
    return 0;
}
```
## 7-51 最长有序子序列
```cpp
#include <bits/stdc++.h>
int main()
{
    int t, c = 0;
    std::cin >> t;
    while (t--)
    {
        int n;
        std::cin >> n;

        std::vector<int> a(n);
        for (int i = 0; i < n; i++)
            std::cin >> a[i];

        std::vector<int> dp(n, 1);
        for (int i = 0; i < n; i++)
            for (int j = 0; j < i; j++)
                if (a[i] > a[j])
                    dp[i] = std::max(dp[i], dp[j] + 1);

        if(c++)
            std::cout << '\n';
        int res = 0;
        for (int i = 0; i < n; i++)
            res = std::max(res, dp[i]);
        std::cout << res << '\n';
    }
    return 0;
}
```
## 7-52 最大连续子序列
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    while(std::cin >> n, n)
    {
        std::vector<int> a(n);
        for(int i = 0; i < n; i++)
            std::cin >> a[i];

        int res = -1, u = 0, v = 0;
        std::vector<int>dp(n);
        for(int i = 0; i < n; i++)
        {
            dp[i] = std::max(dp[i - 1] + a[i], a[i]);
            if(dp[i] > res)
                res = dp[i], v = i;
        }

        for(int i = v; i >= 0; i--)
        {
            if(dp[i] < 0)
            {
                u = i + 1;
                break;
            }
        }

        if(res == -1)
            std::cout << 0 << ' ' << a[0] << ' ' << a[n - 1] << '\n';
        else 
            std::cout << res << ' ' << a[u] << ' ' << a[v] << '\n';
    }
    return 0;
}
```
## 7-53 数塔
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    int t;
    std::cin >> t;
    while (t--)
    {
        int n;
        std::cin >> n;

        std::vector a(n + 1, std::vector<int>(n + 1));
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= i; j++)
                std::cin >> a[i][j];

        std::vector dp(n + 1, std::vector<i64>(n + 1));
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= i; j++)
                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - 1]) + a[i][j];
        i64 res = 0;
        for(int i = 1; i <= n; i++)
            res = std::max(res, dp[n][i]);
        std::cout << res << '\n';
    }
    return 0;
}
```
## 7-54 石子合并
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(n + 1), s(n + 1);
    for (int i = 1; i <= n; i++)
        std::cin >> a[i], s[i] = s[i - 1] + a[i];

    std::vector dp(n + 1, std::vector<int>(n + 1, 0x3f3f3f3f));
    for (int len = 1; len <= n; len++)
    {
        for (int i = 1; i + len - 1 <= n; i++)
        {
            int j = i + len - 1;
            if (len == 1)
            {
                dp[i][j] = 0;
                continue;
            }

            for (int k = i; k <= j - 1; k++)
                dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1]);
        }
    }
    std::cout << dp[1][n] << '\n';
    return 0;
}
```
## 7-55 石子合并
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> a(2 * n + 1), s(2 * n + 1);
    std::vector f(2 * n + 1, std::vector<int>(2 * n + 1));
    std::vector f2(2 * n + 1, std::vector<int>(2 * n + 1));
    
    for(int i = 1; i <= n; i++)
    {    
        std::cin >> a[i];
        a[i + n] = a[i];
    }

    for(int i = 1; i <= 2 * n; i++)
        s[i] = s[i - 1] + a[i];

    for(int len = 2; len <= 2 * n; len++)
    {
        for(int i = 1; i + len - 1 <= 2 * n; i++)
        {
            int j = i + len - 1;
            f2[i][j] = 0x3f3f3f3f;
            for(int k = i; k < j; k++)
            {
                f[i][j] = std::max(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
                f2[i][j] = std::min(f2[i][j], f2[i][k] + f2[k + 1][j] + s[j] - s[i - 1]);
            }
        }
    }

    int min = 0x3f3f3f3f, max = -1;
    for(int i = 1; i <= n; i++)
    {
        max = std::max(max, f[i][i + n - 1]);
        min = std::min(min, f2[i][i + n - 1]);
    }
    std::cout << min <<  '\n' <<  max << '\n';
    return 0;
}
```
## 7-56 超级楼梯1
```cpp
#include <bits/stdc++.h>

using i64 = long long;
constexpr int N = 50;
i64 f[N];

void init()
{
    f[1] = 1, f[2] = 2;
    for (int i = 3; i <= N; i++)
        f[i] = f[i - 1] + f[i - 2];
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    init();

    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-57 超级楼梯2
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 50;
i64 f[N];
void init()
{
    f[1] = 1, f[2] = 2;
    for (int i = 3; i <= N; i++)
        f[i] = f[i - 1] + f[i - 2];
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    init();

    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-58 走楼梯升级版
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 50;
i64 f[N];

void init()
{
    f[1] = 1, f[2] = 2, f[3] = 4;
    for (int i = 4; i <= N; i++)
        f[i] = f[i - 1] + f[i - 2] + f[i - 3];
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    init();

    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-59 sdut-C语言实验-蟠桃记
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int n;
    std::cin >> n;
    int s = 1;
    while (--n)
        s = (s + 1) * 2;
    std::cout << s << '\n';
    return 0;
}
```
## 7-60 一只小蜜蜂
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 50;
i64 f[N];
void init()
{
    f[1] = 1, f[2] = 2;
    for (int i = 3; i <= N; i++)
        f[i] = f[i - 2] + f[i - 1];
}

void solve()
{
    int a, b;
    std::cin >> a >> b;
    std::cout << f[b - a] << '\n';
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    init();

    int t;
    std::cin >> t;
    while (t--)
    {
        solve();
    }

    return 0;
}
```
## 7-61 兔子繁殖问题
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 50;
i64 f[N];
void init()
{
    f[1] = 1, f[2] = 1;
    for (int i = 3; i <= N; i++)
        f[i] = f[i - 2] + f[i - 1];
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    init();

    int n;
    std::cin >> n;
    std::cout << f[n] << '\n';

    return 0;
}
```
## 7-62 骨牌铺方格
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 55;
i64 f[N];
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    f[1] = 1, f[2] = 2;
    for (int i = 3; i < N; i++)
        f[i] = f[i - 1] + f[i - 2];

    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-63 铺满方格
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 55;
i64 f[N];
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    f[1] = 1, f[2] = 2, f[3] = 4;
    for (int i = 4; i < N; i++)
        f[i] = f[i - 1] + f[i - 2] + f[i - 3];

    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-64 sdut-C语言实验-骨牌铺方格
```cpp
#include <bits/stdc++.h>
using i64 = long long;
constexpr int N = 55;
i64 f[N];
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    f[1] = 1, f[2] = 2;
    for (int i = 3; i < N; i++)
        f[i] = f[i - 1] + f[i - 2];
    int n;
    while (std::cin >> n)
        std::cout << f[n] << '\n';

    return 0;
}
```
## 7-65 子集和问题
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;

int n;
long long c;
int a[N];
int sum;
vector<int> q;
bool ok = false;

void dfs(int u, long long w)
{

    if (w == c)
    {
        for (auto x : q)
        {
            cout << x << ' ';
        }

        ok = true;
        return;
    }

    if (u >= n + 1)
        return;
    if (ok)
        return;

    if (w > c)
        return;
    q.push_back(a[u]);
    dfs(u + 1, w + a[u]);
    q.pop_back();

    dfs(u + 1, w);

    return;
}

int main()
{
    cin >> n >> c;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        sum += a[i];
    }

    if (sum < c)
    {
        puts("No Solution!");
        return 0;
    }
    dfs(1, 0);
    if (!ok)
        puts("No Solution!");

    return 0;
}
```
## 7-66 八皇后问题(*)
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    int n;
    std::cin >> n;

    std::vector g(n, std::vector<char>(n, '.'));

    bool flag = false;
    std::vector<bool> row(n), col(n), deg(n), udeg(n);
    std::function<void(int)> dfs = [&](int u)
    {
        if(u == n)
        {
            if(flag)
                std::cout << '\n';
            for(int i = 0; i < n; i++)
            {                
                for(int j = 0; j < n; j++)
                {   
                    if(j) std::cout << ' ';
                    std::cout << g[i][j];
                }
                std::cout << '\n';
            }
            flag = true;
            return;
        }
        for(int i = 0; i < n; i++)
        {
            if(!col[i] && !deg[u + i] && !udeg[i - u + n])
            {
                g[u][i] = 'Q';
                col[i] = deg[u + i] = udeg[i - u + n] = true;
                dfs(u + 1);
                g[u][i] = '.';
                col[i] = deg[u + i] = udeg[i - u + n] = false;
            }
        }
    };
    
    dfs(0);

    if(!flag)    
        std::cout << "None\n";
    return 0;
}
```
## 7-67 工作分配问题
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    int n;
    std::cin >> n;

    std::vector cost(n, std::vector<int>(n));
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            std::cin >> cost[i][j];

    std::vector<int> v(n);
    std::iota(v.begin(), v.end(), 0);

    int res = 0x3f3f3f3f;
    do 
    {
        int t = 0;
        for(int i = 0, x = 0; i < n; i++)
        {    t += cost[x++][v[i]];
        if(t > res)
            break;
         }
        if(t > res)
            continue;
        res = std::min(res, t);
    }
    while(std::next_permutation(v.begin(), v.end()));

    std::cout << res <<'\n';
    
    return 0;
}
```
## 7-68 德邦国王
```cpp
#include <bits/stdc++.h>
using i64 = long long;
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    
	int n, k, m;
	std::cin >> n >> k >> m;

	std::vector<std::pair<int, int>> position(k);
	for (int i = 0; i < k; i++)
		std::cin >> position[i].first >> position[i].second;

	int X, Y;
	std::vector init(n, std::vector<int>(n));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
		{
			std::cin >> init[i][j];
			if (init[i][j] == 2)
				X = i, Y = j;
		}

	std::vector g(n, std::vector<int>(n));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			std::cin >> g[i][j];

	int res = 0x3f3f3f;

	std::function<void(int)> dfs = [&](int cnt)
	{
		int s = 0;
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				if (init[i][j] == g[i][j])
					s++;

		if (init == g)
		{
			res = std::min(res, cnt);
			return;
		}

		if (cnt > m || cnt >= res)
			return;

		// if (m - cnt < n * n - s - 1)
		// 	return;

		for (int i = 0; i < k; i++)
		{
			auto [x, y] = position[i];
			if (X + x < 0 || X + x >= n || Y + y < 0 || Y + y >= n)
				continue;

			int kingx = X, kingy = Y;
			std::swap(init[X + x][Y + y], init[X][Y]);
			X += x, Y += y;
			dfs(cnt + 1);
			std::swap(init[X - x][Y - y], init[X][Y]);
			X -= x, Y -= y;
		}
	};

	dfs(0);

	std::cout << (res <= m ? res : -1) << '\n';

	return 0;
}
```
## 7-69 图着色问题
```cpp
#include <bits/stdc++.h>
int main()
{
	int n, m, k;
	std::cin >> n >> m >> k;

	std::vector<int> adj[n];
	while (m--)
	{
		int u, v;
		std::cin >> u >> v;
		u--, v--;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	int t;
	std::cin >> t;

	while (t--)
	{
		std::vector<int> col(n);
		std::set<int> st;
		for (int i = 0; i < n; i++)
			std::cin >> col[i], st.insert(col[i]);

		if ((int)st.size() != k)
		{
			std::cout << "No\n";
			continue;
		}

		bool flag = false;
		for (int u = 0; u < n; u++)
		{
			for (auto v : adj[u])
			{
				if (col[u] == col[v])
				{
					flag = true;
					break;
				}
				if (flag)
					break;
			}
			if (flag)
				break;
		}
		std::cout << (flag ? "No\n" : "Yes\n");
	}
	return 0;
}
```
## 7-70 最大团问题
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    while(std::cin >> n, n)
    {
        std::vector g(n, std::vector<int>(n));
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                std::cin >> g[i][j];
        
        std::vector<int> v;
        
        auto check = [&](int u)
        {
            for(auto x : v)
            {
                if(!g[x][u])
                    return false;
            }
            return true;
        };

        int res = 0;
        std::function<void(int, int)> dfs = [&](int u, int cnt)
        {
            res = std::max(res, cnt);
            for(int i = u + 1; i < n; i++)
            {
                if(check(i))
                {
                    v.push_back(i);
                    dfs(i, cnt + 1);
                    v.pop_back();
                }
            }
        };

        for(int i = 0; i < n; i++)
        {
            v.push_back(i);
            dfs(i, 1);
            v.clear();
        }
        std::cout << res << '\n';
    }    
    return 0;
}
```
## 7-71 拯救007
```cpp
#include <bits/stdc++.h>
#define x first 
#define y second 
typedef std::pair<int, int> pii;

double get_dis(std::pair<int, int> a, std::pair<int, int> b)
{
    return std::sqrt(std::pow(a.x - b.x, 2) + std::pow(a.y - b.y, 2)); 
}
int main()
{
    int n, d;
    std::cin >> n >> d;
    std::vector<std::pair<int, int>> q(n);
    for(int i = 0; i < n; i++)
        std::cin >> q[i].first >> q[i].second;

    std::vector<int> step;
    std::pair<int, int> st({0, 0});
    for(int i = 0; i < n; i++)
    {
        if(get_dis(q[i], st) <= d + 7.5)
            step.push_back(i);
    }

    if(step.size() == 0)
    {
        std::cout << "No\n";
        return 0;
    }

    std::vector<bool> vis(n);
    std::function<void(int)> dfs = [&](int u)
    {
        vis[u] = true;
        if((50 - std::abs(q[u].x)) <= d || (50 - std::abs(q[u].y) <= d))
        {
            std::cout << "Yes\n";
            exit(0);
        }
        for(int i = 0; i < n; i++)
        {
            if(!vis[i] && get_dis(q[i], q[u]) <= d)
                dfs(i);
        }
    };

    for(auto x : step)
        dfs(x);
    std::cout << "No\n";
    return 0;
}
```
## 7-72 列出连通集
```cpp
#include<bits/stdc++.h>
int main()
{
    int n, m;
    std::cin >> n >> m;

    std::vector<int> adj[n];
    while(m--)
    {
        int u, v;
        std::cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    for(int i = 0; i < n; i++)
        std::sort(adj[i].begin(), adj[i].end());

    std::vector<int> res;
    std::vector<bool> vis(n);
    std::function<void(int)> dfs = [&](int u)
    {
        res.push_back(u);
        vis[u] = true;
        for(auto v : adj[u])
        {
            if(vis[v])
                continue;
            dfs(v);
        }
    };

    for(int i = 0; i < n; i++)
    {
        if(vis[i])
            continue;
        vis[i] = true;
        dfs(i);
        std::cout << "{ ";
        for(auto x : res)
            std::cout << x << ' ';
        std::cout << "}\n";
        res.clear();
    }

    std::fill(vis.begin(), vis.end(), false);
    auto bfs = [&](int u)
    {
        res.push_back(u);
        std::queue<int> q;
        q.push(u);
        while(q.size())
        {
            auto u = q.front();
            q.pop();

            for(auto v : adj[u])
            {
                if(vis[v])
                    continue;
                vis[v] = true;
                q.push(v);
                res.push_back(v);
            }
        }
    };

    for(int i = 0; i < n; i++)
    {
        if(vis[i])
            continue;
        vis[i] = true;
        bfs(i);
        std::cout << "{ ";
        for(auto x : res)
            std::cout << x << ' ';
        std::cout << "}\n";
        res.clear();
    }
    return 0;
}
```
## 7-73 六度空间
```cpp
#include <bits/stdc++.h>
int main()
{
    int n, m;
    std::cin >> n >> m;

    std::vector<int> adj[n];
    while(m--)
    {
        int u, v;
        std::cin >> u >> v;
        u--, v--;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    auto dijkstra = [&](int u)
    {
        std::vector<int> dis(n, 0x3f3f3f3f);
        dis[u] = 0;
        std::vector<bool> vis(n);

        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> q;
        q.push({0, u});
        while(q.size())
        {
            auto [d, u] = q.top();
            q.pop();

            if(vis[u])
                continue;
            vis[u] = true;

            for(auto v : adj[u])
            {
                if(dis[v] > dis[u] + 1)
                {
                    dis[v] = dis[u] + 1;
                    q.push({dis[v], v});
                }
            }
        }

        int cnt = 0;
        for(int i = 0; i < n; i++)
            cnt += dis[i] <= 6;
        std::cout << u  + 1 << ": " << std::fixed << std::setprecision(2) << cnt * 1.0 / n * 100 << "%\n";
    };

    for(int i = 0; i < n; i++)
        dijkstra(i);
    return 0;
}
```
## 7-74 输出全排列
```cpp
#include <bits/stdc++.h>
int main()
{
    int n;
    std::cin >> n;

    std::vector<int> v(n);
    std::iota(v.begin(), v.end(), 0);

    do
    {
        for(int i = 0; i < n; i++)
            std::cout << v[i]+1;
        std::cout << std::endl;
    } while(std::next_permutation(v.begin(), v.end()));

    return 0;
}
```
## 7-75 批处理作业调度
## 7-76 求解流水作业调度问题
## 7-77 旅行售货员
